<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Richo blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Richo's Blog" />
  
  <meta name="description" content="OOP期末考试复习篇（上）装饰器篇：1.函数装饰器：​					1.装饰器的工作原理是替换被装饰的函数。 ​					2.当你应用一个装饰器时，装饰器函数会接受被装饰的函数作为参数，并根据需要对其进行修改或扩展。然后，装饰器函数需要返回一个新的函数，该新函数会取代原始的被装饰函数。 ​					3.首先装饰器要有一个名称，比如square,然后它需要一个参数是函数，我这就把形式参数命名成了ofun">
<meta property="og:type" content="article">
<meta property="og:title" content="Richo blog">
<meta property="og:url" content="https://bztiangou.github.io/Richo.github.io/2023/06/14/OOP%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AF%87(%E4%B8%8A)/index.html">
<meta property="og:site_name" content="Richo blog">
<meta property="og:description" content="OOP期末考试复习篇（上）装饰器篇：1.函数装饰器：​					1.装饰器的工作原理是替换被装饰的函数。 ​					2.当你应用一个装饰器时，装饰器函数会接受被装饰的函数作为参数，并根据需要对其进行修改或扩展。然后，装饰器函数需要返回一个新的函数，该新函数会取代原始的被装饰函数。 ​					3.首先装饰器要有一个名称，比如square,然后它需要一个参数是函数，我这就把形式参数命名成了ofun">
<meta property="og:locale">
<meta property="og:image" content="https://img1.imgtp.com/2023/06/14/RMoFsNOW.jpg">
<meta property="og:image" content="https://img1.imgtp.com/2023/06/14/Hxh5xFhF.jpg">
<meta property="article:published_time" content="2023-06-14T12:15:06.458Z">
<meta property="article:modified_time" content="2023-06-14T14:40:43.720Z">
<meta property="article:author" content="Richo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.imgtp.com/2023/06/14/RMoFsNOW.jpg">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/Richo.github.io/css/style.css">

  
<script src="/Richo.github.io/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/Richo.github.io/" class="left">
                    <span class="site-title">Richo&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/Richo.github.io/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/Richo.github.io/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/Richo.github.io/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/Richo.github.io/">
                    <img src="/Richo.github.io/images/head.jpg" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Richo&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        新手上路，不服憋着
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="MinHow" target="_blank" href="//minhow.com">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/wongminho">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Weibo" target="_blank" href="//weibo.com/WongMinHo">
                            <i class="fa fa-weibo fa-2x"></i></a>
                    
                        <a title="Twitter" target="_blank" href="//twitter.com/huangminhow">
                            <i class="fa fa-twitter fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-OOP期末考试复习篇(上)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h1 id="OOP期末考试复习篇（上）"><a href="#OOP期末考试复习篇（上）" class="headerlink" title="OOP期末考试复习篇（上）"></a>OOP期末考试复习篇（上）</h1><h2 id="装饰器篇："><a href="#装饰器篇：" class="headerlink" title="装饰器篇："></a>装饰器篇：</h2><h3 id="1-函数装饰器："><a href="#1-函数装饰器：" class="headerlink" title="1.函数装饰器："></a>1.函数装饰器：</h3><p>​					1.装饰器的工作原理是替换被装饰的函数。</p>
<p>​					2.当你应用一个装饰器时，装饰器函数会接受被装饰的函数作为参数，并根据需要对其进行修改或扩展。然后，装饰器函数需要返回一个新的函数，该新函数会取代原始的被装饰函数。</p>
<p>​					3.首先装饰器要有一个名称，比如square,然后它需要一个参数是函数，我这就把形式参数命名成了ofunc。随后就需要编写新的函数来代替旧的函数，也即编写隐式传递函数nf，当然，你可以编写多个newfunction，最后返回的时候只需要返回需要替代的那个函数即可。</p>
<p>​					4.也就是说咱的add函数已经没有调用了，实际上用的是square的nf,他需要传入n个参数，这n个参数实际上就是ofunc的参数，然后隐式调用nf</p>
<p>​					5.再次强调square其实只是一个装饰器的名称，不是他被调用</p>
<p>​					6.然后我们就执行具体的函数内容，比如这里则是将ofunc的返回值变成了平方,强调一下ofunc是函数！</p>
<p>​					7.最后我们把nf返回给调用者即可</p>
<p>​			<strong>python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">ofunc</span>):  <span class="comment"># 定义一个装饰器函数square，接收一个函数作为参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nf</span>(<span class="params">*args</span>):  <span class="comment"># 定义一个内部函数nf，接收任意数量的参数</span></span><br><span class="line">    <span class="keyword">return</span> ofunc(*args) ** <span class="number">2</span>  <span class="comment"># 调用传入的函数ofunc，并将其结果平方后返回</span></span><br><span class="line"><span class="keyword">return</span> nf  <span class="comment"># 返回内部函数nf</span></span><br><span class="line"><span class="meta">@square  </span><span class="comment"># 使用装饰器@square，将下面的函数进行装饰</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):  <span class="comment"># 定义一个函数add，接收两个参数</span></span><br><span class="line">    <span class="keyword">return</span> x + y  <span class="comment"># 返回两个参数的和</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 调用装饰后的函数add，并输出结果</span></span><br></pre></td></tr></table></figure>

<h2 id="2-类方法-classmethod"><a href="#2-类方法-classmethod" class="headerlink" title="2.类方法(classmethod):"></a>2.类方法(classmethod):</h2><p>​	<code>@classmethod</code> 是一个装饰器，用于定义类中的方法。被 <code>@classmethod</code> 装饰的方法不需要实例化类对象即可调用，它们操作的是类本身，而不是类的实例。被传递给 <code>@classmethod</code> 的第一个参数通常被命名为 <code>cls</code>，它代表类本身，而不是实例。使用 <code>cls</code> 参数，可以在方法中访问和修改类的属性或调用其他类方法。</p>
<p>与普通函数的装饰器不同，类方法通过类本身来调用，而不是通过类的实例。它们可以访问类的属性，而不需要创建类的实例对象。这使得类方法成为在不创建实例的情况下对类进行操作的有用工具。</p>
<p>以下是一个使用 <code>@classmethod</code> 装饰器的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    MyClass.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_instance_count</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="keyword">return</span> cls.count</span><br><span class="line"><span class="built_in">print</span>(MyClass.get_instance_count())  <span class="comment"># 输出: 0</span></span><br><span class="line"></span><br><span class="line">obj1 = MyClass()</span><br><span class="line"><span class="built_in">print</span>(MyClass.get_instance_count())  <span class="comment"># 输出: 1</span></span><br><span class="line"></span><br><span class="line">obj2 = MyClass()</span><br><span class="line"><span class="built_in">print</span>(MyClass.get_instance_count())  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>get_instance_count</code> 是一个类方法，它通过 <code>cls</code> 参数访问和返回类属性 <code>count</code>。可以直接通过类调用该方法，而无需创建类的实例。</p>
<p>需要注意的是，类方法通常用于在类级别上执行操作，而不是在实例级别上执行操作。因此，类方法中不能直接访问实例的属性。</p>
<h2 id="3-静态方法-staticmethod"><a href="#3-静态方法-staticmethod" class="headerlink" title="3.静态方法(staticmethod):"></a>3.静态方法(staticmethod):</h2><p>​		<code>@staticmethod</code> 是另一个装饰器，用于定义类中的静态方法。静态方法与类方法相似，但没有额外的参数传递给它们。它们既不需要实例化类对象，也不需要类本身作为参数。</p>
<p>静态方法通常用于执行与类相关但与类的实例无关的操作。它们在逻辑上属于类，但不依赖于类的状态或属性。</p>
<p>以下是一个使用 <code>@staticmethod</code> 装饰器的示例：</p>
<p>class MathUtils:<br>    @staticmethod<br>    def add_numbers(x, y):<br>        return x + y</p>
<p>result &#x3D; MathUtils.add_numbers(3, 5)<br>print(result)  # 输出: 8</p>
<p>在上面的示例中，<code>add_numbers</code> 是一个静态方法，它接受两个参数 <code>x</code> 和 <code>y</code>，并返回它们的和。我们可以直接通过类调用静态方法，而无需创建类的实例。</p>
<p>需要注意的是，静态方法与类属性或实例属性无关，它们不可以访问类属性或实例属性。它们仅依赖于传递给它们的参数，并且不对类的状态进行修改。静态方法主要用于组织和封装与类相关的独立功能。</p>
<h2 id="测试单元篇："><a href="#测试单元篇：" class="headerlink" title="测试单元篇："></a>测试单元篇：</h2><h3 id="1-比较常见的单元测试："><a href="#1-比较常见的单元测试：" class="headerlink" title="1.比较常见的单元测试："></a>1.比较常见的单元测试：</h3><p>Python的<code>unittest</code>是一个内置的测试框架，用于编写、组织和执行单元测试。说人话，给你的程序进行结果测试，相当于程序考试。只不过不合格苦的不是代码，而是写这串代码的人，和我们考生考试不一样，苦的不是教我们的人，而是考生自己QWQ！！</p>
<p><code>unittest</code>提供了一组类和方法，用于定义测试用例、执行测试并生成测试报告。它支持自动化执行测试，并提供了丰富的断言方法和测试运行控制功能。</p>
<p>它的常规步骤如下：</p>
<ol>
<li><p>导入<code>unittest</code>模块。</p>
</li>
<li><p>创建一个继承自<code>unittest.TestCase</code>的测试类。</p>
</li>
<li><p>在测试类中定义测试方法，每个方法以<code>test_</code>开头。</p>
</li>
<li><p>在测试方法中使用断言方法对代码的行为进行验证。</p>
</li>
<li><p>可选地，可以在测试方法中使用一些特定的方法，如<code>setUp()</code>和<code>tearDown()</code>，在测试前后执行一些准备和清理操作。</p>
</li>
<li><p>使用<code>unittest.main()</code>或其他方式运行测试。</p>
<p>python示例代码如下：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">import</span> unittest  <span class="comment"># 导入unittest模块，用于编写和运行测试</span></span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>  <span class="comment"># 定义一个函数foo，它将给定的参数x加1并返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span>(unittest.TestCase):  <span class="comment"># 创建一个继承自unittest.TestCase的测试类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_foo</span>(<span class="params">self</span>):  <span class="comment"># 定义一个测试方法test_foo</span></span><br><span class="line">        self.assertEqual(foo(<span class="number">3</span>), <span class="number">4</span>)  <span class="comment"># 使用断言方法self.assertEqual来验证foo(3)的结果是否等于4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()  <span class="comment"># 运行unittest的主程序，自动发现并执行测试方法`</span></span><br></pre></td></tr></table></figure>

<p>特别需要注意的是这里的调用是运行unittest的主程序，而不是实例一个MT的对象再调用test_foo方法，这种错误的做法是没有任何结果的，虽然不会报错。如果报错了，那是你的码力问题。</p>
<h3 id="2-文档测试篇："><a href="#2-文档测试篇：" class="headerlink" title="2.文档测试篇："></a>2.文档测试篇：</h3><p>Python的doctest是一种用于测试和文档编写的工具，它允许你在代码的文档字符串中编写测试用例，并自动运行这些测试用例进行验证。</p>
<p>doctest的测试用例是以<strong>交互式会话</strong>的形式编写在文档字符串中。它模拟了对代码的实际交互，并使用预期的输出结果来验证代码的正确性。这种方式使得测试用例和代码文档保持紧密结合，可以作为示例和使用说明。</p>
<p>是不是懵逼了？</p>
<p>那我来解释一下：1.<strong>文档字符串</strong>（也称为docstring）提供了对函数的说明和文档，帮助其他开发人员理解函数的用途和使用方式。它是一种约定俗成的编写文档的方式，并且可以被工具和库用于自动生成文档。</p>
<p>​								2.<strong>函数的文档字符串</strong>是在函数定义中包含的一个多行字符串，用于描述函数的目的、输入参数、返回值以及示例等信息。它位于函数定义的开头，被三引号（’’’ 或 “””）包围起来。</p>
<p><strong>文档字符串</strong>的内容通常包括以下几个部分：</p>
<ol>
<li>函数的目的和功能的简要描述。</li>
<li>输入参数的说明，包括参数名称、类型和可能的取值范围等。</li>
<li>返回值的说明，包括返回结果的类型和可能的取值。</li>
<li>示例和使用说明，通过使用<code>&gt;&gt;&gt;</code>和预期输出来展示函数的使用方式和期望结果。强调一下&gt;&gt;&gt;表示函数的调用，即函数名+参数</li>
<li>其他相关信息，如异常处理、注意事项、示例调用等。</li>
</ol>
<p>以下是python代码详解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回两个数的和。</span></span><br><span class="line"><span class="string">	示例:</span></span><br><span class="line"><span class="string">	&gt;&gt;&gt; add(3, 3)</span></span><br><span class="line"><span class="string">	6</span></span><br><span class="line"><span class="string">	&gt;&gt;&gt; add(-1, 1)</span></span><br><span class="line"><span class="string">	0</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x + y`</span><br><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    doctest.testmod()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="pytest篇："><a href="#pytest篇：" class="headerlink" title="pytest篇："></a>pytest篇：</h3><p><code>pytest</code>是Python中一种功能强大且易于使用的<strong>第三方测试框架</strong>。它提供了简单而灵活的方式来编写测试用例，并支持自动化发现和运行测试。</p>
<p>与Python内置的<code>unittest</code>相比，<code>pytest</code>具有更简洁的语法和更丰富的功能，能够简化测试编写的过程，并提供丰富的插件生态系统。</p>
<p>python代码如下：</p>
<p>def add(x, y):<br>    return x + y</p>
<p>def test_add():<br>    result &#x3D; add(2, 3)<br>    assert result &#x3D;&#x3D; 5</p>
<p>def test_subtract():<br>    result &#x3D; add(5, 3)<br>    assert result &#x3D;&#x3D; 2 </p>
<p>在上面的示例中，我们定义了两个测试函数<code>test_add</code>和<code>test_subtract</code>，它们分别测试了<code>add</code>函数的加法和减法功能。每个测试函数都使用<code>assert</code>语句来断言测试的结果是否符合预期。</p>
<p>要运行这些测试，只需在命令行中运行<code>pytest</code>命令。<code>pytest</code>会自动发现以<code>test_</code>开头的函数，并执行它们。运行结果将显示每个测试的状态（通过、失败等）以及相关的详细信息。</p>
<p>强调一下，第三方是让你下载模块的意思pip install pytest,别不看说明就直接跑，然后报错了要抹我脖子。瑟瑟发抖的我QWQ.</p>
<p>测试篇就到此结束了。如有不懂，算你倒霉。</p>
<h2 id="模式篇："><a href="#模式篇：" class="headerlink" title="模式篇："></a>模式篇：</h2><h3 id="python的成语："><a href="#python的成语：" class="headerlink" title="python的成语："></a>python的成语：</h3><p>Python idioms指的是在Python编程中常用的惯用法或最佳实践，它们旨在使代码更加清晰、简洁、可读性强，并且符合Python社区的共识。</p>
<ol>
<li>列表推导式<code>squares = [x**2 for x in range(1, 6)]</code></li>
</ol>
<p>2.生成器表达式 <code>squares = (x**2 for x in range(1, 6))</code></p>
<p>3.使用enumerate函数获取索引和值：</p>
<p><code>fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;] for i, fruit in enumerate(fruits):     print(i, fruit)</code></p>
<p>使用<code>enumerate</code>函数可以同时获取迭代对象的索引和值，提高代码的可读性。</p>
<p>4.使用字典的get方法获取默认值：</p>
<p><code>fruits = &#123;&#39;apple&#39;: 3, &#39;banana&#39;: 5&#125; count = fruits.get(&#39;orange&#39;, 0)</code></p>
<p>使用<code>get</code>方法可以在字典中获取指定键的值，如果键不存在，则返回默认值。</p>
<p>5.使用with语句进行资源管理：</p>
<p>with open(‘file.txt’, ‘r’) as f:<br>    content &#x3D; f.read()</p>
<p>6.使用装饰器（Decorators）实现代码重用和功能增强：</p>
<p>def log(func):<br>    def wrapper(*args, **kwargs):<br>        print(‘Calling’, func.<strong>name</strong>)<br>        return func(*args, **kwargs)<br>    return wrapper</p>
<p>@log<br>def add(x, y):<br>    return x + y</p>
<h2 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a>设计模式：</h2><p>这个比较抽象。指的是在Python编程中常用的设计模式。设计模式是解决常见设计问题的可重复使用的解决方案，它们提供了一种在软件设计中处理特定情况的方法和模板。</p>
<p>设计模式的目的是提高代码的可重用性、可维护性、可扩展性和可理解性。它们是从实践中总结出来的，经过广泛验证和应用的解决方案。</p>
<p>首先说四个基本要素：模式名称，问题，解决，后果</p>
<h4 id="迭代器模式（Iterator-Pattern）："><a href="#迭代器模式（Iterator-Pattern）：" class="headerlink" title="迭代器模式（Iterator Pattern）："></a>迭代器模式（Iterator Pattern）：</h4><p>迭代器模式（Iterator Pattern）是一种行为型设计模式：，它提供一种访问集合对象（如列表、字典等）元素的方式，而不暴露其内部结构。迭代器模式将遍历集合的责任封装在迭代器对象中，使得可以使用统一的接口来遍历不同类型的集合。</p>
<p>在Python中，迭代器模式已经内置在语言中，并且被广泛使用。Python中的可迭代对象（Iterable）是指实现了<code>__iter__()</code>方法的对象，而迭代器对象（Iterator）则是实现了<code>__iter__()</code>和<code>__next__()</code>方法的对象。</p>
<p>下面是一个简单的示例，演示了如何使用迭代器模式在Python中遍历列表元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.index &gt;= <span class="built_in">len</span>(self.data):</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line">    value = self.data[self.index]</span><br><span class="line">    self.index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">my_iterator = MyIterator(my_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_iterator:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>



<p>让我解释一下：我们定义了一个<code>MyIterator</code>类，它实现了迭代器接口。该迭代器接受一个列表作为数据，并在每次调用<code>__next__()</code>方法时返回列表中的下一个元素。</p>
<p>然后，我们创建一个<code>my_iterator</code>对象，并使用<code>for</code>循环遍历该迭代器对象。在每次迭代中，<code>for</code>循环会调用迭代器的<code>__next__()</code>方法来获取下一个元素，并将其打印出来。</p>
<p>通过迭代器模式，我们可以将遍历集合的责任封装在迭代器对象中，使得使用者可以通过简单的接口来访问集合的元素，而无需了解集合的内部实现细节。这提高了代码的灵活性和可维护性，同时也符合Python的迭代协议，使得迭代在Python中更加便捷和直观。</p>
<h4 id="适配器模式（Adapter-Pattern）："><a href="#适配器模式（Adapter-Pattern）：" class="headerlink" title="适配器模式（Adapter Pattern）："></a>适配器模式（Adapter Pattern）：</h4><p>适配器模式（Adapter Pattern）是一种结构型设计模式，它允许将一个类的接口转换成另一个类所期望的接口，从而使得原本由于接口不兼容而无法一起工作的类能够协同工作。</p>
<p><strong>接口</strong>：接口（Interface）是一种约定或契约，定义了类或对象应该提供的方法、属性或行为。接口描述了一个类或对象可以做什么，而不关注其具体实现细节。</p>
<p>在Python中，适配器模式常用于以下情况：</p>
<ol>
<li>将现有类的接口转换为另一个接口。</li>
<li>与第三方库或旧版本的代码进行集成。</li>
</ol>
<p>通过适配器模式，我们可以将两个不兼容的接口协调起来，而无需修改已有的类或代码。</p>
<p>不兼容性可能包括以下情况：</p>
<ol>
<li><p>方法签名不匹配：两个类具有相同的方法名称，但参数类型、参数个数或返回类型不同。</p>
</li>
<li><p>方法命名不一致：两个类具有相似的功能，但方法名称不同。</p>
</li>
<li><p>数据类型不匹配：两个类使用不同的数据结构或数据类型来表示相似的概念。</p>
</li>
<li><p>业务逻辑不一致：两个类的功能逻辑或行为方式有所不同。</p>
<p>通过引入适配器类，我们可以在适配器中实现对不兼容接口的转换和协调，以便两个类能够无缝地进行交互。适配器类将原本不兼容的接口封装起来，使得外部调用者无需了解接口的不一致性，而只需通过适配器的统一接口与两个类进行交互。</p>
</li>
</ol>
<p>下面是一个简单的示例，演示了如何使用适配器模式在Python中将一个类的接口转换为另一个类的接口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;如果你看到了我，表示没有替换成功&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">specific_request</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Adaptee&#x27;s specific request&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span>(<span class="title class_ inherited__">Target</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, adaptee</span>):</span><br><span class="line">        self.adaptee = adaptee</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>):</span><br><span class="line">    	self.adaptee.specific_request()</span><br><span class="line">adaptee = Adaptee()</span><br><span class="line">adapter = Adapter(adaptee)</span><br><span class="line">adapter.request()</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们有一个<code>Target</code>接口，它定义了期望的接口方法<code>request()</code>。然后，我们有一个<code>Adaptee</code>类，它拥有一个不兼容的方法<code>specific_request()</code>。接下来，我们创建了一个适配器<code>Adapter</code>，它继承自<code>Target</code>并持有一个<code>Adaptee</code>对象。在适配器的<code>request()</code>方法中，我们将调用<code>Adaptee</code>的<code>specific_request()</code>方法。</p>
<p>通过适配器模式，我们可以使用<code>Adapter</code>类来调用<code>Adaptee</code>类的方法，并将其转换为符合<code>Target</code>接口的调用。这样，我们就可以将原本不兼容的接口协调起来，实现了适配器模式。</p>
<p>适配器模式的目的是通过适配器类<code>Adapter</code>来解决接口不兼容的问题。在适配器类中，通过将<code>Adaptee</code>类的<code>specific_request()</code>方法适配为<code>Target</code>接口中的<code>request()</code>方法，实现了接口的统一。这样，我们可以通过适配器对象来调用<code>request()</code>方法，从而间接地调用<code>Adaptee</code>类的<code>specific_request()</code>方法。</p>
<p>适配器模式在Python中常常用于与第三方库或旧版本的代码进行集成，以便于在现有系统中使用新的功能或组件。它提供了一种灵活且不侵入性的方法来实现接口转换和兼容性。</p>
<h4 id="策略模式（Strategy-Pattern）："><a href="#策略模式（Strategy-Pattern）：" class="headerlink" title="策略模式（Strategy Pattern）："></a>策略模式（Strategy Pattern）：</h4><p>策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一族算法或行为，并将每个算法封装到独立的类中，使得它们可以相互替换。这种模式允许算法独立于使用它的客户端进行变化，从而提高了代码的灵活性和可维护性。</p>
<p>在Python中，策略模式通常用于以下情况：</p>
<ol>
<li>需要在运行时根据不同的条件选择不同的算法或行为。</li>
<li>需要将算法的具体实现与调用代码分离，以便于扩展和维护。</li>
<li>需要实现一个算法族，使得可以在运行时动态选择合适的算法。</li>
</ol>
<p>下面是一个简单的示例，说明如何在Python中使用策略模式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentStrategy</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreditCardPayment</span>(<span class="title class_ inherited__">PaymentStrategy</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Paying $&#123;&#125; with Credit Card&quot;</span>.<span class="built_in">format</span>(amount))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PayPalPayment</span>(<span class="title class_ inherited__">PaymentStrategy</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Paying $&#123;&#125; with PayPal&quot;</span>.<span class="built_in">format</span>(amount))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingCart</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, payment_strategy</span>):</span><br><span class="line">        self.payment_strategy = payment_strategy</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">checkout</span>(<span class="params">self, amount</span>):</span><br><span class="line">    	self.payment_strategy.pay(amount)</span><br><span class="line">credit_card_strategy = CreditCardPayment()</span><br><span class="line">paypal_strategy = PayPalPayment()</span><br><span class="line"></span><br><span class="line">cart = ShoppingCart(credit_card_strategy)</span><br><span class="line">cart.checkout(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">cart.payment_strategy = paypal_strategy</span><br><span class="line">cart.checkout(<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<p>如果上述代码出现缩进问题请根据编译器报错位置移动空格即可。</p>
<p>在上述示例中，我们定义了一个策略接口<code>PaymentStrategy</code>，它包含了一个<code>pay()</code>方法。然后，我们有两个具体的策略类<code>CreditCardPayment</code>和<code>PayPalPayment</code>，它们分别实现了<code>PaymentStrategy</code>接口，并提供了自己的<code>pay()</code>方法。</p>
<p>在<code>ShoppingCart</code>类中，我们通过构造函数接收一个具体的支付策略，并在<code>checkout()</code>方法中调用支付策略的<code>pay()</code>方法来实现支付功能。</p>
<p>通过使用策略模式，我们可以在运行时动态地选择不同的支付策略。在示例中，我们创建了一个购物车对象，并分别使用信用卡和PayPal作为支付策略进行结算。</p>
<p>这样，我们可以根据需要选择不同的支付策略，而无需修改购物车类的代码。策略模式将算法的具体实现与调用代码分离，提供了一种灵活的方式来应对不同的需求，并使代码具有扩展性和可维护性。</p>
<h2 id="git部分："><a href="#git部分：" class="headerlink" title="git部分："></a>git部分：</h2><p>Git将数据存储为快照，因此克隆是项目的完整备份</p>
<p> 好像没啥好看的，直接上命令吧：</p>
<p><img src="https://img1.imgtp.com/2023/06/14/RMoFsNOW.jpg" alt="git 命令"></p>
<p><img src="https://img1.imgtp.com/2023/06/14/Hxh5xFhF.jpg" alt="中文版"></p>
<p>git log 不是登录，是当前分支的版本历史记录</p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2023年06月14日 22:40</p>
        <p>原始链接： <a class="post-url" href="/Richo.github.io/2023/06/14/OOP%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AF%87(%E4%B8%8A)/" title="">https://bztiangou.github.io/Richo.github.io/2023/06/14/OOP%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AF%87(%E4%B8%8A)/</a></p>
        <footer>
            <a href="https://bztiangou.github.io/Richo.github.io">
                <img src="/Richo.github.io/images/head.jpg" alt="Richo">
                Richo
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/Richo.github.io/images/wechatpay.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/Richo.github.io/images/wechatpay.jpg">
                <img class="reward-select-item-wechat" src="/Richo.github.io/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/Richo.github.io/images/zhifubao.jpg">
                <img class="reward-select-item-alipay" src="/Richo.github.io/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://bztiangou.github.io/Richo.github.io/2023/06/14/OOP%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AF%87(%E4%B8%8A)/&title=Richo blog&pic=https://bztiangou.github.io/Richo.github.ioimages/head.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://bztiangou.github.io/Richo.github.io/2023/06/14/OOP%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AF%87(%E4%B8%8A)/&title=Richo blog&source=新手上路，不服憋着" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://bztiangou.github.io/Richo.github.io/2023/06/14/OOP%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AF%87(%E4%B8%8A)/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=Richo blog&url=https://bztiangou.github.io/Richo.github.io/2023/06/14/OOP%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AF%87(%E4%B8%8A)/&via=https://bztiangou.github.io/Richo.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://bztiangou.github.io/Richo.github.io/2023/06/14/OOP%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AF%87(%E4%B8%8A)/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://bztiangou.github.io/Richo.github.io/2023/06/14/OOP%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AF%87(%E4%B8%8A)/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#OOP%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="post-toc-text">OOP期末考试复习篇（上）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%AF%87%EF%BC%9A"><span class="post-toc-text">装饰器篇：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9A"><span class="post-toc-text">1.函数装饰器：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-%E7%B1%BB%E6%96%B9%E6%B3%95-classmethod"><span class="post-toc-text">2.类方法(classmethod):</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-staticmethod"><span class="post-toc-text">3.静态方法(staticmethod):</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B5%8B%E8%AF%95%E5%8D%95%E5%85%83%E7%AF%87%EF%BC%9A"><span class="post-toc-text">测试单元篇：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-%E6%AF%94%E8%BE%83%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%9A"><span class="post-toc-text">1.比较常见的单元测试：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-%E6%96%87%E6%A1%A3%E6%B5%8B%E8%AF%95%E7%AF%87%EF%BC%9A"><span class="post-toc-text">2.文档测试篇：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pytest%E7%AF%87%EF%BC%9A"><span class="post-toc-text">pytest篇：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%AF%87%EF%BC%9A"><span class="post-toc-text">模式篇：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#python%E7%9A%84%E6%88%90%E8%AF%AD%EF%BC%9A"><span class="post-toc-text">python的成语：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="post-toc-text">设计模式：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Iterator-Pattern%EF%BC%89%EF%BC%9A"><span class="post-toc-text">迭代器模式（Iterator Pattern）：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter-Pattern%EF%BC%89%EF%BC%9A"><span class="post-toc-text">适配器模式（Adapter Pattern）：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy-Pattern%EF%BC%89%EF%BC%9A"><span class="post-toc-text">策略模式（Strategy Pattern）：</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#git%E9%83%A8%E5%88%86%EF%BC%9A"><span class="post-toc-text">git部分：</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
  
    <a href="/Richo.github.io/2023/06/01/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title"></span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2023 Richo<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://bztiangou.github.io/Richo.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            
        </div>
        <div id="sidebar-menu-box-tags">
            
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/Richo.github.io/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/Richo.github.io/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/Richo.github.io/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/Richo.github.io/js/search.js"></script>


<script src="/Richo.github.io/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/Richo.github.io/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/Richo.github.io/js/animate.js"></script>



  
<script src="/Richo.github.io/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>