<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JAVA | Richo blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Richo's Blog" />
  
  <meta name="description" content="Java有C&#x2F;C++基础入门java，文档篇 我的C++使用的是MinGW平台的g++编译器，而Java则用的是一种集成工具JDK，JDK：它包含了开发、编译、调试和运行Java应用程序所需的工具和库。 如下：  Java编译器（javac）：用于将Java源代码编译成字节码文件（.class 文件）。 Java虚拟机（JVM）：用于在计算机上运行Java应用程序。JVM将字节码文件转化">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA">
<meta property="og:url" content="https://bztiangou.github.io/Richo.github.io/2023/07/12/Java/index.html">
<meta property="og:site_name" content="Richo blog">
<meta property="og:description" content="Java有C&#x2F;C++基础入门java，文档篇 我的C++使用的是MinGW平台的g++编译器，而Java则用的是一种集成工具JDK，JDK：它包含了开发、编译、调试和运行Java应用程序所需的工具和库。 如下：  Java编译器（javac）：用于将Java源代码编译成字节码文件（.class 文件）。 Java虚拟机（JVM）：用于在计算机上运行Java应用程序。JVM将字节码文件转化">
<meta property="og:locale">
<meta property="og:image" content="https://img1.imgtp.com/2023/07/11/D3wQAgz0.png">
<meta property="article:published_time" content="2023-07-11T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-01T15:40:14.573Z">
<meta property="article:author" content="Richo">
<meta property="article:tag" content="编程语言">
<meta property="article:tag" content="期末考">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.imgtp.com/2023/07/11/D3wQAgz0.png">
  
  
    <link rel="icon" href="images/head.jpg">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/Richo.github.io/css/style.css">

  
<script src="/Richo.github.io/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/Richo.github.io/" class="left">
                    <span class="site-title">Richo&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/Richo.github.io/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/Richo.github.io/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/Richo.github.io/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/Richo.github.io/">
                    <img src="/Richo.github.io/images/head.jpg" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Richo&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        来都来了,github点个关注呗
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="githubtoo" target="_blank" href="https://github.com/BZtiangou/">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="https://github.com/BZtiangou/">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Weibo"  target="_blank" rel="noopener" href="//weibo.com/WongMinHo">
                            <i class="fa fa-weibo fa-2x"></i></a>
                    
                        <a title="Twitter"  target="_blank" rel="noopener" href="//twitter.com/huangminhow">
                            <i class="fa fa-twitter fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      JAVA
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/Richo.github.io/categories/JAVA/">JAVA</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2023-07-12
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>有C&#x2F;C++基础入门java，文档篇</p>
<p>我的C++使用的是MinGW平台的g++编译器，而Java则用的是一种集成工具JDK，JDK：它包含了开发、编译、调试和运行Java应用程序所需的工具和库。</p>
<p>如下：</p>
<ol>
<li>Java编译器（javac）：用于将Java源代码编译成字节码文件（.class 文件）。</li>
<li>Java虚拟机（JVM）：用于在计算机上运行Java应用程序。JVM将字节码文件转化为机器码，以便执行。</li>
<li>Java标准库：包括了Java类库和API，提供了各种用于开发Java应用程序的类和方法。这些库包含了各种功能，如输入&#x2F;输出、集合、图形用户界面、网络通信等。</li>
<li>开发工具：JDK还包括用于开发和调试Java应用程序的工具，如调试器、性能分析工具等。</li>
</ol>
<p>.class: 字节码是一种中间代码，它是由Java源代码编译而成，用于在Java虚拟机（JVM）上执行。</p>
<p><strong>注释</strong></p>
<p>使用和C&#x2F;C++的常用注释方法一样，&#x2F;&#x2F; 和&#x2F;**&#x2F;分别进行单行注释和多行注释。</p>
<p><strong>标识符</strong></p>
<p>类似于C&#x2F;C++&#x2F;python的变量名</p>
<p><strong>打印</strong></p>
<ol>
<li>print为一般输出，同样不能保留精度格式转化，也不能换行输出<br>2.printf常用于格式转换，但需要注意不是换行输出，只用于精度转换<br>3.println为换行输出，不能用于格式转换</li>
</ol>
<p><strong>以下内容中所有C均是C&#x2F;C++的缩写</strong>……</p>
<p>说在页面中要打印东西你可以用print，你要是用system.out.print就会在服务器的控制台输出，而不在页面输出。print多用于通过java语言而不是html向页面输出值，system.out.print方便在调试程序的时候通过控制台跟踪信息</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p>和C一样，都是有那几种数据类型，只不过他把指针改成了数据引用</p>
<p><strong>byte</strong>:主要用于网络传输，二进制处理，编码转换  -128-127范围</p>
<p>它有一个优化，只要你没有超过他的范围，就不需要转换，否则就要强转。</p>
<p><strong>int</strong>:描述大部分的整型数值;<br><strong>long:<strong>主要描述文件大小或者是日期时间的数字(讲解到</strong>类库</strong>的时候会进行说明)</p>
<p><strong>赋值</strong>的时候特别注意：</p>
<p>在JDK1.4及以前的版本要在定义的同时给出值，但是在1.5以后可以先声明，后定义。</p>
<p>同时你也可以在方法外开(相当于全局变量，默认0)</p>
<p><strong>数据溢出</strong>和C一样(应该都一样，和计算机构造有关)</p>
<p><strong>数据转换</strong></p>
<p>数据类型小的遇到大的会<strong>自动</strong>像大的转：小遇到转大</p>
<p><strong>手动</strong>：强制类型转换(有可能出现溢出)  方法和C一样</p>
<p><strong>字符编码上的区别：</strong></p>
<p>Java自己的十六进制编码，该编码的名称为“UNICODE“</p>
<p>UNICODE 描述了一个更广阔的编码范围，其中也很好的支持有传统的 ASCI I编码，让所有的开发者在使用上不会产生任何的不适应感，由于字符<strong>可以保存中文</strong>，所以在日后进行<strong>网络数据传输</strong>的时候，如果要进行中文数据的处理，建议使用的就是 char来进行操作。</p>
<p><strong>布尔型的区别：</strong></p>
<p>boolean  不能使用 bool   并且，0&#x2F;1已经不能替代false跟true了</p>
<p><strong>字符串类型</strong></p>
<p>字符串的+ 基础类型(整，浮，字符，<strong>布尔</strong>) 都能正常完成拼接 ，没有’-‘法!!!</p>
<p>空也是null</p>
<p><strong>优先级：</strong></p>
<p>如果是字符串+浮点+整型，执行顺序如下：</p>
<p>先把浮点转换为字符串，拼接前面，再把整型转成字符串，再拼接。而<strong>不是</strong>把整形转浮点，计算后相加！</p>
<p>如果要在字符串里放一些<strong>奇怪的符号</strong>比如双引号，单引号，<strong>转义</strong>，要记得转义！和C一样需要转义！</p>
<p><strong>推断式变量</strong></p>
<p>JDK1.10以后才有，关键字是var</p>
<p>类似于C++11的auto，<strong>方便</strong>，但是也有缺点！</p>
<p>Java不支持类字段的类型推断。</p>
<p><strong>缺点</strong>：</p>
<p>1.不适合后续维护，其他程序员真的看不懂，麻烦</p>
<p>2.Java的Var有一个致命缺点，一旦推断出，那么该变量类型不允许改变</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p><strong>运算符：</strong></p>
<p>编程语言的本质是数学的计算   –冯诺依曼公式</p>
<p>自增或自减性能更高(在栈内存中执行)，注意是自！别人计算有用到你，但是你自增也影响不到用你的人！</p>
<p><strong>关系符号：</strong></p>
<p>提醒：和C一样，字符比较是会帮你转换成数字，但是是用UNICODE编码</p>
<p>布尔类型要作比较的时候<strong>只能用等于或者不等于，绝不能用其他关系运算符</strong>，否则会报错操作数错误</p>
<p><strong>三目运算：</strong></p>
<p>和C一样，主要用来判断谁来作为赋值的常量罢了。小心<strong>三目嵌套</strong>就可以了</p>
<p><strong>逻辑运算：</strong></p>
<p>和C不同！&amp;一个与是正常与，等同于C++的&amp;&amp;,但是JAVA的&amp;&amp;的意思是短路与，意思是我只要在判读过程中能知道结果了，我就不会在执行剩下的语句，可以显著提高性能的同时可以避免这种报错2&gt;1 &amp;&amp; 2&#x2F;0&#x3D;&#x3D;0。</p>
<p>或也是同理</p>
<p><strong>位运算：</strong></p>
<p>~ 取反码 &gt;&gt;&gt;无符号右移</p>
<p><strong>if分支</strong>：</p>
<p>只要不同在于if(x)不能简写了</p>
<p><strong>switch</strong>:</p>
<p>如果没有遇到break，会持续匹配下去</p>
<p><img src="https://img1.imgtp.com/2023/07/11/D3wQAgz0.png" alt="switch"></p>
<p>和C一样不能使用逻辑语句。</p>
<p><strong>Yield关键字</strong></p>
<p>JDK13之后</p>
<p>局部内容返回   -&gt;1 </p>
<p><strong>while 和 do while</strong></p>
<p>和C一样，do while是先执行do里面的东西一次，然后while判断，决定是否要做do里面的东西</p>
<p><strong>方法重载</strong></p>
<p>和C相同，同名不同参数。会根据实际调用时传入的参数调用相对应的函数。<strong>小心返回值被坑</strong></p>
<p>例子：print</p>
<p><strong>类</strong></p>
<p>和C++差不多，是引用数据类型，默认值是null，比如string</p>
<p><strong>static</strong></p>
<p>在Java中，<code>static</code>是一个关键字，用于声明静态成员。静态成员可以是<strong>静态变量或静态方法</strong>。当变量或方法被声明为静态时，它们与<strong>类</strong>相关联，而<strong>不是与类的实例</strong>相关联。</p>
<p>当一个成员被声明为静态时，它在内存中只有<strong>一个副本，</strong>无论创建了多少个类的实例。这意味着，<strong>所有的实例都共享相同的静态变量和静态方法</strong>。</p>
<p>静态变量（也称为类变量）是在类级别声明的变量，可以在类的任何地方访问，而不需要创建类的实例。可以通过使用类名来访问静态变量，例如<code>ClassName.variableName</code>。</p>
<p>静态方法是在类级别声明的方法，可以<strong>通过类名直接调用</strong>，而无需创建类的实例。静态方法通常用于实现与类相关的实用功能，而不依赖于特定的实例。</p>
<h2 id="内存处理方面"><a href="#内存处理方面" class="headerlink" title="内存处理方面"></a>内存处理方面</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>和C一样，内存分栈内存和堆内存，栈内存主要存的是堆的一个编号地址，而堆内存主要存放的是具体的对象(属性)。程序中通过对象名称来表示。</p>
<p>JVM类似于CPU，它要执行他自己的指令集</p>
<p>和C一样，Java也有一个new关键字，可以开辟堆空间</p>
<p>使用内存上比较严格，如果只是声明了这个变量&#x3D;null (在栈内存里面开了一个变量，而没有去堆内存开辟空间是没法使用的)  空指针错误</p>
<p>旧值丢失：破坏性存储进程，反之则不是</p>
<p>执行结束：执行结束，内存被清空</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>多个栈内存可以指向同一个堆内存，反之不行。</p>
<p>实质：堆内存可以由多个栈内存引用。</p>
<p>好处在于你可以对内存精准修改来实现修改，不用担心被销毁。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>例子：渣男结婚了，遇到了一个美女，他就要先离婚再和美女结婚(如果他有实力的话)</p>
<p>也就是如果一个堆内存被创建了，但是它的联系人栈内存指向别人了(一个美女结婚了，但是老公出轨了)，那么这个美女就会被GC自动回收。</p>
<p>GC回收机制，JVM会负责释放所有已分配的内存，包括堆空间中的对象。因此，不需要在程序结束时显式地释放堆空间。与C不同，C需要手动delete。</p>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>一个Java源文件可以包含多个类，但只能有一个类声明为<code>public</code>。以下是关于<code>class</code> 和 <code>public class</code> 的区别：</p>
<ol>
<li><code>class</code> 关键字：<ul>
<li><code>class</code> 是用于定义类的关键字，它可以出现在一个Java源文件中多次，每次用于定义一个新的类。</li>
</ul>
</li>
</ol>
<p>2.<code>public class</code> 关键字：</p>
<ul>
<li><code>public class</code> 也是用于定义类的关键字，但它将一个类声明为公共类，这意味着这个类可以被其他包中的类访问。</li>
<li>一个Java源文件中只能有一个<code>public class</code> 声明，且该类的名称必须与源文件的名称一致。</li>
</ul>
<p>与python不同的是：Java里的类定义的方法不需要传入self绑定实例对象</p>
<h2 id="Private"><a href="#Private" class="headerlink" title="Private"></a>Private</h2><p>私有变量：将变量封装起来，不允许除了秘密通道以外的所有更改和访问(print),但是你可以使用暗道来对它进行访问或者修改。</p>
<p>暗道一般由public 关键字 +函数组成。由于没有实例对象的传输，所以直接对变量更改即可！例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setname</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getname</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><p>定义： public + 类名 () {}</p>
<p>如果没有写，在编译的时候都会默认出现一个无参构造。</p>
<p>特点：</p>
<p>1.没有返回值，<strong>也不能写返回值</strong>！ 包括void！因为编译器认不出来！</p>
<p>2.名称必&#x3D;类名！ </p>
<p>3.可以写多个构造方法来接不同参数，但只能在new()的时候<strong>只调用一次！</strong>而且最好对参数的个数进行升序或者降序排列</p>
<p>进一步剖析什么时候调用的：</p>
<p>Book book &#x3D; new Book()</p>
<p>我们可以发现第四个Book（）带了一个括号，括号是函数特有的！那这时候就可以发现一个关联了，Book就是我们的构造方法！</p>
<p>匿名对象：一次性用品，当你使用完毕后就会被自动销毁，不能接着引用。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Something is being done by MyClass.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建匿名对象并调用方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyClass</span>().doSomething();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建匿名对象并传递给方法</span></span><br><span class="line">        process(<span class="keyword">new</span> <span class="title class_">MyClass</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名对象也可以作为方法的返回值</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">anotherObject</span> <span class="operator">=</span> createObject();</span><br><span class="line">        anotherObject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(MyClass obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Processing the object.&quot;</span>);</span><br><span class="line">        obj.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyClass <span class="title function_">createObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并返回一个匿名对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="This-处理"><a href="#This-处理" class="headerlink" title="This 处理"></a>This 处理</h3><p>只要在类中加了this.+属性 就会特指在本类中的属性。</p>
<p>按照正常的设计思维来讲，类之中的普通方法调用的形式应该为“对象.方法()”，但是如果要是在本类中调用本类方法的时候可以直接编写方法名称，而如果要想更加明确的描述调用本类方法的话则最好编写的形式为“this.方法()”。</p>
<p>构造方法互相调用</p>
<p>1.只能用在构造方法中</p>
<p>2.只能由构造方法来调用构造(重载)</p>
<p>Java 中的类属于引用数据类型，引用数据类型之中需要去考虑堆栈的引用关系，发现如果直接进行对象的输出所获得的就是一个对象的编码，而这种编码的格式为“类名称@编码”(这个是由 Java 内部默认决定的程序结构)。</p>
<p>整个的 Java 里面 this 是一个可以被灵活改变的内容，它会随着当前调用的实化对象的不同而有所不同，那么在之前所分析过的“this方法0”或者是“is.成员属性”，严格意义上来进它所描述的就是当前调用的实例化对象中的方法或者是属性。</p>
<p><strong>Static 关键字</strong></p>
<p>在堆中的一个公共数据存放区域，由类名直接更改(因为取交集)</p>
<p><strong>extends 继承</strong></p>
<p>super()表示父类的代号。可以用super(“参数”)来调用父类的构造方法。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="定义与开辟"><a href="#定义与开辟" class="headerlink" title="定义与开辟"></a>定义与开辟</h2><p>数组的动态开辟：</p>
<p>int name [] &#x3D; new int [size];  #所有值都会变成该类型的初始值：比如int 是0；</p>
<p>获取长度的方法：name.length</p>
<p>分布式：</p>
<p>int name [] &#x3D;null</p>
<p>name &#x3D; new int [size]</p>
<p>#中括号的位置也可以放中间，但是影响不大</p>
<p>静态数组开辟：</p>
<p>int name [] &#x3D;new int []    + {xxx};</p>
<p>foreach语法和c一样；</p>
<p>数组的内存分析</p>
<p>与类相似，也可以实现不同的栈内存对同一块堆内存进行修改！</p>
<p>数组与方法</p>
<p>形参定义：(int temp [])  与C不同之处在于指针 ，在后面加[] ！ 形参修改：和C一样会在函数结束时死亡，但是修改了堆内存空间则会把修改内容保存下来！</p>
<p>使用x.clone()则是新开一个空间放</p>
<p>按值传递:将参数值的副本传递给被调用的方法。被调用的方法只对副本起作用。对副本的更改不会影响原始变量的值。<br>通过引用传递被调用的方法可以直接访问调用方中的参数值，并在必要时修改该数据。这可以通过消除复制大量数据的需要来提高性能。</p>
<p>二维：</p>
<p>数据类型 数组名称 [] [] &#x3D; new 数据类型[行个数] [列个数];</p>
<h1 id="GUI-lesson7"><a href="#GUI-lesson7" class="headerlink" title="GUI lesson7"></a>GUI lesson7</h1><h2 id="Java-Foundation-Classes（JFC）"><a href="#Java-Foundation-Classes（JFC）" class="headerlink" title="Java Foundation Classes（JFC）"></a>Java Foundation Classes（JFC）</h2><p>JFC 是 Java 中用于创建具有丰富图形功能和用户界面的应用程序的一组功能，它使开发人员能够构建交互性强、外观可定制、无障碍友好且国际化的应用程序。 Swing 是其中的一部分，提供了跨平台的 GUI 组件。</p>
<p>JFC 包括以下功能：</p>
<ol>
<li><strong>Swing GUI 组件（Swing GUI Components）：</strong> JFC 包括 Swing 库，它提供了一组丰富的 GUI 组件，如按钮、文本框、标签、表格、列表框等，用于创建用户友好的桌面应用程序界面。Swing 是 JFC 的一部分，用于构建跨平台的 Java 应用程序的图形用户界面。</li>
<li><strong>可插拔的外观支持（Pluggable look-and-feel Support）：</strong> JFC 允许应用程序的外观和感觉可以轻松定制。开发人员可以选择不同的外观风格，使应用程序的外观与用户期望的一致。</li>
<li><strong>无障碍 API（Accessibility API）：</strong> JFC 包括支持无障碍性的 API，使得应用程序更易于使用对于有特殊需求或残障的用户。这意味着开发人员可以创建可访问的应用程序，以确保所有用户都能够轻松地与应用程序进行交互。</li>
<li><strong>Java 2D API：</strong> Java 2D API 提供了用于处理二维图形和图像的功能，包括绘图、渲染、图像处理等。它使开发人员能够在应用程序中实现丰富的图形功能。</li>
<li><strong>国际化（Internationalisation）：</strong> JFC 支持国际化，使得开发人员能够轻松地将应用程序本地化为不同的语言和文化环境，以满足不同用户群体的需求。</li>
</ol>
<p> <strong>Java Swing</strong> 中的 GUI 组件和如何使用它们来构建图形用户界面（GUI）应用程序的基本概念：</p>
<ol>
<li><p><strong>Swing 组件（Swing components）：</strong> 在 Swing 中，GUI 是由图形组件构成的，这些组件是 Java 类的实例。这些组件用于构建用户界面的各个部分，如按钮、文本框、标签等。开发人员可以使用这些组件来构建用户友好的应用程序界面。</p>
</li>
<li><p><strong>声明组件对象（Declare objects of them）：</strong> 要使用 Swing 组件，开发人员需要声明这些组件的对象。这通常涉及创建相应组件的实例，然后将它们添加到 GUI 中，以构建应用程序的用户界面。</p>
</li>
<li><p><strong>JFrame 组件（JFrame component）：</strong> 通常，GUI 应用程序是建立在 <code>JFrame</code> 组件之上的。<code>JFrame</code> 是一个窗口或容器，用于容纳应用程序的其他组件。它提供了应用程序窗口的框架，并允许开发人员管理窗口的大小、位置以及其他窗口相关的属性。</p>
</li>
<li><p><strong>其他常用组件（Other commonly used components）：</strong> 除了 <code>JFrame</code> 外，Swing 还包括许多其他常用的组件，例如：</p>
<ul>
<li><code>JLabel</code>：用于显示静态文本或图像的组件。</li>
<li><code>JButton</code>：实现了可按下的按钮，用于触发操作或事件。</li>
</ul>
<p>这些组件允许开发人员创建各种用户界面元素，如标签、按钮等，以构建功能丰富的图形用户界面。</p>
</li>
</ol>
<p>在 Java Swing 中，<code>JDialog</code> 类用于创建顶层容器，通常用于显示对话框。对话框是一种独立的窗口，用于与用户进行短期的交互，例如接受输入或提供信息，而 <code>JDialog</code> 类是创建这些对话框的工具。</p>
<h2 id="非模态"><a href="#非模态" class="headerlink" title="非模态"></a>非模态</h2><p>“Non-modal” 是一个与用户界面（UI）和用户交互模式相关的术语。在非模态（non-modal）交互中，用户可以在执行一个任务的同时执行其他任务，而不需要完全完成或关闭当前任务。与之相反的是”modal”（模态）交互，其中用户需要完成或关闭当前任务，然后才能继续执行其他任务。</p>
<p>下面是一些关于非模态（non-modal）的概念和示例：</p>
<ol>
<li><strong>同时执行多个任务：</strong> 在非模态的交互中，用户可以同时执行多个任务或操作。例如，用户可以打开多个非模态窗口或对话框，而不需要等待一个窗口的操作完成才能打开另一个窗口。</li>
<li><strong>实时反馈和更新：</strong> 在非模态交互中，用户可以随时与应用程序的不同部分进行交互，查看实时反馈和更新。例如，用户可以在查看文件的同时进行搜索，而不需要等待搜索任务完成。</li>
<li><strong>更大的灵活性：</strong> 非模态交互提供了更大的灵活性，用户可以根据需要切换任务，而不受强制的顺序或顺序要求。</li>
</ol>
<p>示例：Web浏览器通常采用非模态的交互方式。用户可以同时打开多个选项卡，每个选项卡都代表一个独立的网页或任务。用户可以在不关闭一个选项卡的情况下切换到另一个选项卡，查看不同的网页。这种方式与模态的文件打开对话框不同，后者通常要求用户选择文件后才能继续其他操作。</p>
<ol>
<li><strong>图形用户界面（GUI）提供用户友好的交互方式：</strong> GUI 是一种用户界面，它为用户提供了与应用程序进行交互的可视化方式。GUI 往往更容易学习和使用，因为它使用图形元素，如按钮、文本框和菜单，来代表应用程序的功能和选项。</li>
<li><strong>不同平台上的 GUI 通常有相似的逻辑但不同的外观：</strong> 尽管不同操作系统上的 GUI 可能在外观上有所不同，但它们通常具有相似的逻辑和功能。这使得用户可以在不同平台上使用相似的应用程序而不需要重新学习如何使用它们。</li>
<li><strong>Swing 是 Java 中常用的 GUI 库：</strong> 在 Java 编程中，Swing 是一个常用的库，用于创建跨平台的 GUI 应用程序。它提供了一组丰富的 GUI 组件和工具，使开发者能够轻松地构建用户友好的图形界面。</li>
<li><strong>Swing 中的 GUI 组件基于 JComponent 类：</strong> 在 Swing 中，不同的 GUI 组件（如按钮、文本框、标签等）是通过继承自 <code>JComponent</code> 类的子类来实现的。这些组件可以在应用程序中创建和定制，以满足特定的需求。</li>
<li><strong>Swing 允许不同的布局来组织 GUI 组件：</strong> Swing 提供了布局管理器（Layout Manager）来帮助开发者组织和排列 GUI 组件。这允许开发者创建具有不同布局的用户界面，以实现特定的设计和外观。</li>
<li><strong>一些典型的 GUI 组件被介绍：</strong> 文本中提到了一些常见的 GUI 组件，包括按钮（buttons）、文本字段（text fields）和菜单项（menu items）。这些组件是构建用户界面的基本构建块，它们可以用于执行各种交互操作。</li>
</ol>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>在每个文件头上加上package</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>在并发编程中，程序代码块(例如，方法)在<strong>重叠的时间段内</strong>并发执行</p>
<p>在并发编程中有两个基本的执行单元:</p>
<p><strong>进程</strong>:每个进程都有一个自包含的执行环境(完整的、私有的运行时资源集，即它自己的内存空间)  操作系统分配资源的最小单位(包括CPU『这里的CPU指CPU核心』、内存、磁盘IO等)。一个进程可以拥有多个线程。</p>
<p>线程和进程的关系是密切的，前面所说[线程是CPU调度和分配的基本单位]，但是计算机资源是多种多样的（包括CPU『这里的CPU指CORE核心』、内存、磁盘IO等），因此操作系统在分配这些资源的时候，是以进程为单位进行分配。操作系统调度的也是进程。</p>
<p><strong>线程</strong>:每个线程存在于一个进程中(每个进程至少有一个线程)，因此线程共享进程的资源，包括内存和打开的文件在Java编程中，我们主要关注线程。线程是CPU调度和分配的基本单位。一个进程下的线程共享该进程的资源和程序代码。</p>
<p>线程才是真正执行的单位，而执行任务的是CORE核心。于是有【线程是CPU调度和分配的基本单位】。也解释了【不论这个线程是哪个进程的，CPU眼里没有进程的概念这个说法】</p>
<p>在大多数支持多核的操作系统上，都能实现把一个进程的多个线程放不同的核心上跑。一个进程可能由多个线程组成，而线程的实现有两种方式，一种是内核调度的线程，可以运行在多个核上，还有一种是用户级线程，这个就没办法跑到多个核上了。</p>
<p>线程可能分为内核态线程和用户态线程。</p>
<p><strong>上下文切换</strong></p>
<p>通常，多线程是通过使用上下文切换在操作系统中实现的线程以轮询方式使用短时间槽运行(每个线程轮流进行)，从而产生CPU多任务处理的错觉</p>
<p>并发的关键是你有处理多个任务的能力，不一定要同时。</p>
<p>并行的关键是你有同时处理多个任务的能力。</p>
<p>同步方法：该方法被声明为 <code>synchronized</code>，这意味着一次只能有一个线程执行这个方法。这是为了防止在模拟中两辆车同时进入十字路口，从而避免碰撞。</p>
<p>synchronized 是 Java 语言中一个关键字，用于实现多线程之间的同步。它有两种主要用法：<br>同步方法：当一个方法被声明为 synchronized 时，它表示该方法在同一时刻只能被一个线程执行。当一个线程进入同步方法时，它会获得一个锁，直到方法执行完毕才释放锁。这样一来，其他线程就需要等待锁的空闲才能执行该方法，从而实现了线程间的同步。<br>同步代码块：在需要同步的代码段前使用 synchronized 关键字，可以确保在执行该代码段时，只有一个线程能够进入同步代码块。这可以用于确保在执行某些操作时，多个线程之间的数据一致性。</p>
<h1 id="Java-数据库"><a href="#Java-数据库" class="headerlink" title="Java-数据库"></a>Java-数据库</h1><p><strong>序列化和反序列化数据</strong></p>
<p>序列化是将数据结构或对象转换为<strong>更容易保存或传输的字节流</strong>的过程相反的过程，反序列化，是从字节流构造数据结构或对象的过程</p>
<p>Java本机序列化</p>
<p>Java支持实现Serializable接口的对象的本机序列化本机序列化的主要优点是它是内置在Java中的，不需要任何外部库本机序列化的</p>
<p>主要缺点是它是特定于java的:默认情况下，序列化的对象<strong>不能直接用于其他平台序列化的类</strong>需要实现一个没有参数的构造函数，以及序列化实例变量的标准格式的getter和setter方法</p>
<p><strong>XML 和 JSON</strong></p>
<p>XML和JSON的比较JSON是另一种常用的表示对象的格式最初为JavaScript开发，但也可以与Java或其他语言一起使用JSON更紧凑，生成和解析速度更快JSON格式对人类来说更容易读和写</p>
<p>另一方面，JSON的可扩展性和灵活性不如XML</p>
<p>JSON更适合简单的数据和web应用程序</p>
<p>XML更适合大型和复杂的数据，以及需要频繁转换和验证的应用程序</p>
<p>数据库基础如果应用程序需要处理大量有组织的数据，如表或模式，直接使用文件是不方便的应用程序必须为每种不同的数据结构定义文件格式应用程序必须实现在文件中添加和删除数据数据库是有组织的数据和信息的集合，由数据库管理系统(DBMS)管理。</p>
<p>DBMS为应用程序提供了<strong>创建数据库、保存不同类型的数据、更新和删除数据等接口</strong>。在多个用户使用相同数据的情况下，DBMS确保数据的<strong>一致性和安全性</strong>.</p>
<p><strong>关系数据库</strong></p>
<p>关系数据库是最流行的数据库类型逻辑数据结构和物理文件存储结构是分开的逻辑数据在表中结构化，</p>
<p>其中每一列是一个属性，每一行是具有系统分配的唯一ID的记录</p>
<p>数据库可以包括用于不同类型数据的多个表，一个表中的数据可以引用另一个表中的数据</p>
<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型(POM)  POM (ProjectObject Model):项目对象模型</p>
<p><strong>仓库</strong><br>仓库:用于存储资源，包含各种jar包<br>仓库分类:<br>本地仓库:自己电脑上存储资源的仓库，连接远程仓库获取资源远程仓库:非本机电脑上的仓库，为本地仓库提供资源中央仓库:Maven团队维护，存储所有资源的仓库<br>私服:部门&#x2F;公司范围内存储资源的仓库，从中央仓库获取资源<br>私服的作用<br>保存具有版权的资源，包含购买或自主研发的iar<br>中央仓库中的iar都是开源的，不能存储具有版权的资源一定范围内共享资源，仅对内部开放，不对外共享</p>
<p>可以通过conf对仓库存放的地址进行更改</p>
<p><strong>坐标</strong><br>什么是坐标?<br>Maven中的坐标用于描述仓库中资源的位置<a target="_blank" rel="noopener" href="https://repo1.maven.org/maven2">https://repo1.maven.org/maven2</a><br>Maven坐标主要组成<br>groupld:定义当前Maven项目隶属组织名称(通常是域名反写，例如:orgmybatis)artifactld:定义当前Maven项目名称(通常是模块名称，例如CRM、SMS)version:定义当前项目版本号<br>packaging:定义该项目的打包方式<br>Maven坐标的作用<br>使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成</p>
<p>项目结构：</p>
<p>在src同层目录下必须包含pom.xml 是用来解释你的项目。包含项目的各种信息(依赖，版本号，打包成jar……)</p>
<p>执行命令也是在pom.xml下</p>
<p>main 放 java 和resource两个文件夹。 分别对应源文件和依赖资源</p>
<p>test  放 java 和resource两个文件夹。 分别对应源文件和依赖资源</p>
<p>主要命令：</p>
<p>Maven构建命令使用mvn开头，后面添加功能参数，可以一次执行多个命令，使用空格分隔<br>mvn compile #编译<br>mvn clean #清理<br>mvn test #测试<br>mvn package #打包<br>mvn install #安装到本地仓库</p>
<p>配置依赖：</p>
<p>依赖具有传递性</p>
<p>在xml里面，dependence里面：群组id,项目id，版本号 (统称坐标)<br>如果需要用到不同项目作为资源，需要把另外一个项目的坐标作为依赖写入</p>
<p>直接依赖：一度依赖</p>
<p>间接依赖：大于一度的依赖</p>
<p>可选依赖：+一个optional标签 隐藏依赖</p>
<p>排除依赖：不要传递过来的依赖</p>
<p>依赖冲突：路径优先，同路径则声明优先(一度优先级最高)</p>
<h1 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h1><h2 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h2><p>Java Swing是一个用于构建图形用户界面(GUI)的框架，而Swing布局管理器（Swing Layout Managers）是用来帮助开发者管理和安排GUI组件的工具。Swing提供了多种布局管理器，以适应不同的界面设计需求。以下是一些常见的Swing布局管理器：</p>
<ol>
<li><p><strong>FlowLayout（流式布局）</strong>：按照添加组件的顺序在容器中从左到右、从上到下排列组件。当一行放不下时，会自动换行到下一行。</p>
</li>
<li><p><strong>BorderLayout（边界布局）</strong>：将容器分为五个区域：北、南、东、西和中心。每个区域只能容纳一个组件，用于创建简单的框架结构。</p>
</li>
<li><p><strong>GridLayout（网格布局）</strong>：将容器分为行和列，然后将组件按照网格的方式排列。所有的单元格大小相等。</p>
</li>
<li><p><strong>CardLayout（卡片布局）</strong>：可以在同一个容器中管理多个组件，但只显示一个组件。通过切换卡片来显示不同的组件。</p>
</li>
<li><p><strong>BoxLayout（盒式布局）</strong>：按照水平或垂直方向排列组件。可以灵活地组合水平盒和垂直盒以创建复杂的布局。</p>
</li>
<li><p><strong>GridBagLayout（网格袋布局）</strong>：通过设置组件的行、列、行跨度和列跨度等属性，实现更为灵活和复杂的布局。</p>
</li>
</ol>
<p>这些布局管理器可以单独使用，也可以组合使用，以满足不同界面布局的需求。通过选择合适的布局管理器，开发者可以更方便地设计出具有良好外观和用户体验的Swing界面。</p>
<h2 id="修饰符（Access-Modifier）"><a href="#修饰符（Access-Modifier）" class="headerlink" title="修饰符（Access Modifier）"></a>修饰符（Access Modifier）</h2><p>在Java中，访问修饰符（Access Modifier）用于定义类、方法、变量等在不同类或包中的可见性和访问权限。Java提供了四种主要的访问修饰符：</p>
<ol>
<li><strong>public（公共的）:</strong><ul>
<li>修饰的成员在任何地方都是可见的。</li>
<li>其他类可以访问公共成员。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> publicVar;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>protected（受保护的）:</strong><ul>
<li>修饰的成员对于同一包中的其他类和所有子类可见。</li>
<li>其他包中的类不能访问受保护的成员。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> protectedVar;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">protectedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>default（默认的）:</strong><ul>
<li>如果没有使用任何访问修饰符，默认为默认访问修饰符。</li>
<li>修饰的成员对于同一包中的其他类可见，但对于不同包中的类不可见。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> defaultVar;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>private（私有的）:</strong><ul>
<li>修饰的成员只对于同一类中的其他成员可见，不能被其他类访问。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> privateVar;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些访问修饰符帮助程序员控制类的封装性和成员的可见性，以便有效地设计和组织代码。</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p><code>final</code> 是Java中的一个关键字，用于修饰类、方法和变量，具有不同的含义和作用：</p>
<ol>
<li><strong>final 类:</strong><ul>
<li>一个被声明为 <code>final</code> 的类不能被继承。这样的类是最终实现，不允许其他类继承它。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FinalClass</span> &#123;</span><br><span class="line">    <span class="comment">// code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>final 方法:</strong><ul>
<li>一个被声明为 <code>final</code> 的方法不能被子类重写。即子类不能修改或覆盖该方法。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>final 变量:</strong><ul>
<li>一个被声明为 <code>final</code> 的变量是一个常量，其值在声明后不能被修改。如果是基本数据类型，它的值不能改变；如果是引用类型，它指向的对象不能改变，但对象的内部状态可能是可变的。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MY_CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>final</code> 的使用有助于提高代码的安全性、可读性和性能。在类、方法或变量上使用 <code>final</code> 可以强制一些约定，也可以被编译器用来进行一些优化。</p>
<h2 id="调用栈（Call-Stack）"><a href="#调用栈（Call-Stack）" class="headerlink" title="调用栈（Call Stack）"></a>调用栈（Call Stack）</h2><p>在Java中，调用栈（Call Stack）是一个存储方法调用的内存区域，用于跟踪程序执行的流程。每当一个方法被调用，一个新的栈帧（Stack Frame）会被创建并推送到调用栈的顶部。当方法执行完成时，对应的栈帧会被弹出。这个过程形成了一个后进先出（LIFO）的结构。</p>
<p>调用栈的主要作用是跟踪方法的调用关系和管理方法的局部变量。让我们来看一下调用栈的主要组成部分：</p>
<ol>
<li><p><strong>栈帧（Stack Frame）:</strong></p>
<ul>
<li>每个方法调用在调用栈上都有一个对应的栈帧。</li>
<li>包含了方法的局部变量、操作数栈、方法返回地址等信息。</li>
<li>当一个方法被调用时，一个新的栈帧被创建并推送到调用栈的顶部；当方法执行完成时，对应的栈帧会被弹出。</li>
</ul>
</li>
<li><p><strong>局部变量表（Local Variable Table）:</strong></p>
<ul>
<li>存储了方法中的局部变量，包括方法参数和在方法中定义的局部变量。</li>
<li>变量表的索引从0开始，用于快速访问局部变量。</li>
</ul>
</li>
<li><p><strong>操作数栈（Operand Stack）:</strong></p>
<ul>
<li>用于存储方法执行过程中的操作数。</li>
<li>例如，进行算术运算时，操作数会被推送到操作数栈上，然后执行相应的操作。</li>
</ul>
</li>
<li><p><strong>方法返回地址:</strong></p>
<ul>
<li>记录了方法调用后需要返回的地址。</li>
<li>当方法执行完成时，程序会回到这个地址，继续执行调用方法之后的代码。</li>
</ul>
</li>
</ol>
<p>调用栈的典型使用场景是方法的递归调用。每次递归调用都会在调用栈上创建一个新的栈帧，形成多个嵌套的栈帧，直到递归结束，栈帧一个一个地被弹出。</p>
<p>理解调用栈对于调试和理解程序执行流程非常重要。如果在递归调用或方法调用中发生错误，通过查看调用栈可以追踪到发生问题的地方。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>在Java中，用于允许只有一个线程同时访问某个方法的关键字是 <code>synchronized</code>。当一个方法被声明为 synchronized 时，它确保在同一时间内只有一个线程能够在该对象上执行该方法。这对于在多线程环境中防止数据损坏或意外行为非常有用。以下是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他非同步方法也可以存在于类中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>increment</code> 方法被声明为 synchronized，确保如果多个线程尝试在同一个 <code>MyClass</code> 对象上调用该方法，只有一个线程能够同时执行它。</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p><code>wait()</code> 方法是 <code>Object</code> 类中的一个方法，而不是 <code>Thread</code> 类的方法。<code>wait()</code> 方法的主要作用是使当前线程暂停执行，等待其他线程通过调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法来唤醒它。</p>
<p>具体来说，当一个线程调用某个对象的 <code>wait()</code> 方法时，它会释放该对象的锁，并进入等待状态，直到其他线程通过相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法来通知它。一旦被通知，线程将重新竞争该对象的锁，并继续执行。</p>
<h2 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h2><p>Method <code>start()</code> of a <code>Thread</code> object is invoked to run the thread.</p>
<p>调用 <code>Thread</code> 对象的 <code>start()</code> 方法来启动线程。</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>使用文件（Using Files）是指在程序中处理文件数据的操作。以下是对这个主题的详细解释：</p>
<ol>
<li><p><strong>文件的用途：</strong></p>
<ul>
<li>文件用于共享数据并长期保存数据。</li>
<li>在计算机中，文件是用于存储信息的主要方式，可以包含文本、图像、音频、视频等各种数据。</li>
</ul>
</li>
<li><p><strong>Java 中的文件操作：</strong></p>
<ul>
<li>Java 提供了多个类和方法来处理文件和目录，包括创建、读取和写入文件。</li>
<li>主要的文件操作相关类包括 <code>File</code> 类、<code>FileReader</code> 和 <code>FileWriter</code> 类用于文本文件，以及 <code>FileInputStream</code> 和 <code>FileOutputStream</code> 类用于二进制文件。</li>
</ul>
</li>
<li><p><strong>按顺序读取和写入文件：</strong></p>
<ul>
<li>文件通常是按顺序读取和写入的，即通过输入流（Input Stream）和输出流（Output Stream）的方式进行。</li>
<li>文本文件可以使用字符流进行读写，而二进制文件通常使用字节流进行读写。</li>
</ul>
</li>
<li><p><strong>文本文件和二进制文件：</strong></p>
<ul>
<li>在Java中，可以处理文本文件和二进制文件。</li>
<li><strong>文本文件：</strong> 包含可读的字符数据，通常使用字符流（<code>FileReader</code> 和 <code>FileWriter</code>）进行处理。</li>
<li><strong>二进制文件：</strong> 包含非文本数据，通常使用字节流（<code>FileInputStream</code> 和 <code>FileOutputStream</code>）进行处理。</li>
</ul>
</li>
</ol>
<p>以下是一个简单的例子，演示了Java中如何使用字符流和字节流读取和写入文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 写入文本文件</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;example.txt&quot;</span>)) &#123;</span><br><span class="line">            writer.write(<span class="string">&quot;Hello, this is a text file example.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文本文件</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;example.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> character;</span><br><span class="line">            <span class="keyword">while</span> ((character = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>) character);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用 <code>FileWriter</code> 写入文本文件，并使用 <code>FileReader</code> 读取文本文件。需要注意的是，在实际应用中，为了更好的性能和灵活性，可能会使用缓冲流（<code>BufferedReader</code> 和 <code>BufferedWriter</code>）来处理文件操作。</p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2024年01月01日 23:40</p>
        <p>原始链接： <a class="post-url" href="/Richo.github.io/2023/07/12/Java/" title="JAVA">https://bztiangou.github.io/Richo.github.io/2023/07/12/Java/</a></p>
        <footer>
            <a href="https://bztiangou.github.io/Richo.github.io">
                <img src="/Richo.github.io/images/head.jpg" alt="Richo">
                Richo
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/Richo.github.io/images/wechatpay.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/Richo.github.io/images/wechatpay.jpg">
                <img class="reward-select-item-wechat" src="/Richo.github.io/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/Richo.github.io/images/zhifubao.jpg">
                <img class="reward-select-item-alipay" src="/Richo.github.io/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://bztiangou.github.io/Richo.github.io/2023/07/12/Java/&title=《JAVA》 — Richo blog&pic=/images/banner.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://bztiangou.github.io/Richo.github.io/2023/07/12/Java/&title=《JAVA》 — Richo blog&source=有需自取，拒绝打赏" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://bztiangou.github.io/Richo.github.io/2023/07/12/Java/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JAVA》 — Richo blog&url=https://bztiangou.github.io/Richo.github.io/2023/07/12/Java/&via=https://bztiangou.github.io/Richo.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://bztiangou.github.io/Richo.github.io/2023/07/12/Java/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://bztiangou.github.io/Richo.github.io/2023/07/12/Java/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/Richo.github.io/tags/编程语言/" class="color5">编程语言</a>
      
    <a href="/Richo.github.io/tags/期末考/" class="color4">期末考</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Java"><span class="post-toc-text">Java</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">数据类型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%AC%A6%E5%8F%B7"><span class="post-toc-text">符号</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86%E6%96%B9%E9%9D%A2"><span class="post-toc-text">内存处理方面</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="post-toc-text">基础</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BC%95%E7%94%A8"><span class="post-toc-text">引用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="post-toc-text">垃圾回收</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">类和对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Private"><span class="post-toc-text">Private</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="post-toc-text">构造方法：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#This-%E5%A4%84%E7%90%86"><span class="post-toc-text">This 处理</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84"><span class="post-toc-text">数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BC%80%E8%BE%9F"><span class="post-toc-text">定义与开辟</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#GUI-lesson7"><span class="post-toc-text">GUI lesson7</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Java-Foundation-Classes%EF%BC%88JFC%EF%BC%89"><span class="post-toc-text">Java Foundation Classes（JFC）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9D%9E%E6%A8%A1%E6%80%81"><span class="post-toc-text">非模态</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%8C%85"><span class="post-toc-text">包</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="post-toc-text">线程</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Java-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="post-toc-text">Java-数据库</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Maven"><span class="post-toc-text">Maven</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0"><span class="post-toc-text">期末复习</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Swing"><span class="post-toc-text">Swing</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%88Access-Modifier%EF%BC%89"><span class="post-toc-text">修饰符（Access Modifier）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#final"><span class="post-toc-text">final</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%B0%83%E7%94%A8%E6%A0%88%EF%BC%88Call-Stack%EF%BC%89"><span class="post-toc-text">调用栈（Call Stack）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link"><span class="post-toc-text"></span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#synchronized"><span class="post-toc-text">synchronized</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#wait"><span class="post-toc-text">wait</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#start"><span class="post-toc-text">start()</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="post-toc-text">文件操作</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/Richo.github.io/2023/07/13/AI%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86%E4%B8%8E%E8%AF%86%E5%88%AB/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          视觉处理与识别
        
      </span>
    </a>
  
  
    <a href="/Richo.github.io/2023/07/09/GCC%20%E5%92%8C%20CPP%E7%AD%89%E5%90%8C%E5%90%97%EF%BC%9F%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">编译器</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2025 Richo<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://bztiangou.github.io/Richo.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/Richo.github.io/categories/C-%EF%BC%8C%E5%BC%80%E5%8F%91%E5%BA%95%E5%B1%82/">C++，开发底层</a><a class="category-link" href="/Richo.github.io/categories/CS/">CS</a><a class="category-link" href="/Richo.github.io/categories/CS%EF%BC%8CCSS%EF%BC%8CXML/">CS，CSS，XML</a><a class="category-link" href="/Richo.github.io/categories/CS%EF%BC%8Cmath/">CS，math</a><a class="category-link" href="/Richo.github.io/categories/CS%EF%BC%8C%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/">CS，数字电路</a><a class="category-link" href="/Richo.github.io/categories/JAVA/">JAVA</a><a class="category-link" href="/Richo.github.io/categories/Python/">Python</a><a class="category-link" href="/Richo.github.io/categories/Python%EF%BC%8C%E5%BC%80%E5%8F%91/">Python，开发</a><a class="category-link" href="/Richo.github.io/categories/language/">language</a><a class="category-link" href="/Richo.github.io/categories/life/">life</a><a class="category-link" href="/Richo.github.io/categories/python%EF%BC%8Ccs/">python，cs</a><a class="category-link" href="/Richo.github.io/categories/sql/">sql</a><a class="category-link" href="/Richo.github.io/categories/web/">web</a><a class="category-link" href="/Richo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a><a class="category-link" href="/Richo.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><a class="category-link" href="/Richo.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a><a class="category-link" href="/Richo.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/">软件工程导论</a><a class="category-link" href="/Richo.github.io/categories/%E8%BD%AF%E5%AF%BC%E5%A4%A7%E4%BD%9C%E4%B8%9A/">软导大作业</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/Richo.github.io/tags/domjudge-%E5%AE%9E%E4%B9%A0/" style="font-size: 10px;">domjudge/实习</a> <a href="/Richo.github.io/tags/life/" style="font-size: 10px;">life</a> <a href="/Richo.github.io/tags/python/" style="font-size: 10px;">python</a> <a href="/Richo.github.io/tags/web%E5%BC%80%E5%8F%91/" style="font-size: 10px;">web开发</a> <a href="/Richo.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 16px;">人工智能</a> <a href="/Richo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 10px;">后端开发</a> <a href="/Richo.github.io/tags/%E5%A4%A7%E5%88%9B/" style="font-size: 16px;">大创</a> <a href="/Richo.github.io/tags/%E5%AE%9E%E4%B9%A0/" style="font-size: 12px;">实习</a> <a href="/Richo.github.io/tags/%E5%BC%80%E5%8F%91/" style="font-size: 10px;">开发</a> <a href="/Richo.github.io/tags/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">开发基础</a> <a href="/Richo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/Richo.github.io/tags/%E6%96%87%E6%A1%A3%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">文档语言</a> <a href="/Richo.github.io/tags/%E6%9C%9F%E6%9C%AB%E8%80%83/" style="font-size: 20px;">期末考</a> <a href="/Richo.github.io/tags/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/" style="font-size: 14px;">期末考试</a> <a href="/Richo.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">机器学习</a> <a href="/Richo.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a> <a href="/Richo.github.io/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 12px;">编程规范</a> <a href="/Richo.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 12px;">编程语言</a> <a href="/Richo.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/" style="font-size: 10px;">编译器</a> <a href="/Richo.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">网络基础</a> <a href="/Richo.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 18px;">计算机基础</a> <a href="/Richo.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/" style="font-size: 12px;">软件工程导论</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/Richo.github.io/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/Richo.github.io/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/Richo.github.io/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/Richo.github.io/tags/domjudge-%E5%AE%9E%E4%B9%A0/" style="font-size: 10px;">domjudge/实习</a> <a href="/Richo.github.io/tags/life/" style="font-size: 10px;">life</a> <a href="/Richo.github.io/tags/python/" style="font-size: 10px;">python</a> <a href="/Richo.github.io/tags/web%E5%BC%80%E5%8F%91/" style="font-size: 10px;">web开发</a> <a href="/Richo.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 16px;">人工智能</a> <a href="/Richo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 10px;">后端开发</a> <a href="/Richo.github.io/tags/%E5%A4%A7%E5%88%9B/" style="font-size: 16px;">大创</a> <a href="/Richo.github.io/tags/%E5%AE%9E%E4%B9%A0/" style="font-size: 12px;">实习</a> <a href="/Richo.github.io/tags/%E5%BC%80%E5%8F%91/" style="font-size: 10px;">开发</a> <a href="/Richo.github.io/tags/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">开发基础</a> <a href="/Richo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/Richo.github.io/tags/%E6%96%87%E6%A1%A3%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">文档语言</a> <a href="/Richo.github.io/tags/%E6%9C%9F%E6%9C%AB%E8%80%83/" style="font-size: 20px;">期末考</a> <a href="/Richo.github.io/tags/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/" style="font-size: 14px;">期末考试</a> <a href="/Richo.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">机器学习</a> <a href="/Richo.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a> <a href="/Richo.github.io/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 12px;">编程规范</a> <a href="/Richo.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 12px;">编程语言</a> <a href="/Richo.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/" style="font-size: 10px;">编译器</a> <a href="/Richo.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">网络基础</a> <a href="/Richo.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 18px;">计算机基础</a> <a href="/Richo.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/" style="font-size: 12px;">软件工程导论</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/Richo.github.io/js/search.js"></script>


<script src="/Richo.github.io/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/Richo.github.io/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/Richo.github.io/js/animate.js"></script>



  
<script src="/Richo.github.io/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>